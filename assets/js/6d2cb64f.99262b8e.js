"use strict";(self.webpackChunkbadger_home=self.webpackChunkbadger_home||[]).push([[3166],{5025:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/algorithms-overview","title":"Optimization Algorithms Overview","description":"Nelder-Mead","source":"@site/versioned_docs/version-1.4/guides/algorithms-overview.md","sourceDirName":"guides","slug":"/guides/algorithms-overview","permalink":"/Badger/docs/guides/algorithms-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/SLAC-ML/Badger-Home/edit/master/versioned_docs/version-1.4/guides/algorithms-overview.md","tags":[],"version":"1.4","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Templates","permalink":"/Badger/docs/guides/templates"},"next":{"title":"Color by Environment","permalink":"/Badger/docs/guides/color-by-environment"}}');var o=n(4848),s=n(8453);const r={sidebar_position:4},a="Optimization Algorithms Overview",l={},c=[{value:"Nelder-Mead",id:"nelder-mead",level:2},{value:"Extremum Seeking",id:"extremum-seeking",level:2},{value:"Expected Improvement (Bayesian Optimization)",id:"expected-improvement-bayesian-optimization",level:2},{value:"RCDS",id:"rcds",level:2}];function d(e){const i={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"optimization-algorithms-overview",children:"Optimization Algorithms Overview"})}),"\n",(0,o.jsx)(i.h2,{id:"nelder-mead",children:"Nelder-Mead"}),"\n",(0,o.jsx)(i.p,{children:"Iterative downhill simplex algorithm which seeks to find local optima by sampling initial points and then using a heuristic to choose the next point during each iteration. Nelder-Mead has been widely used inside accelerator physics."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Low computational cost"}),"\n",(0,o.jsx)(i.li,{children:"Historically proven performance in the context of accelerator physics"}),"\n",(0,o.jsx)(i.li,{children:"Automatic/adaptive hyperparameter specification depending on problem characteristics"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Local optimizer \u2013 sensitive to initial starting conditions"}),"\n",(0,o.jsx)(i.li,{children:"Sensitive to measurement noise which can negatively impact convergence to optimum"}),"\n",(0,o.jsx)(i.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,o.jsx)(i.li,{children:"Cannot handle observational constraints"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"extremum-seeking",children:"Extremum Seeking"}),"\n",(0,o.jsx)(i.p,{children:"Perform small oscillations to measurement to slowly move towards minimum. This algorithm uses a sinusoidal sampling strategy for each parameter to slowly drift towards optimal operating conditions and track time dependent changes in the optimal operating conditions over time. It\u2019s useful for time dependent optimization, where short term drifts in accelerator conditions can lead to a time dependent objective function."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Low computational cost"}),"\n",(0,o.jsx)(i.li,{children:"Can track time-dependent drifts of the objective function to maintain an optimal operating configuration"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Local optimizer, sensitive to initial starting conditions"}),"\n",(0,o.jsx)(i.li,{children:"Additional hyperparameters that must be tuned to a given optimization problem"}),"\n",(0,o.jsx)(i.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,o.jsx)(i.li,{children:"Cannot handle observational constraints"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"expected-improvement-bayesian-optimization",children:"Expected Improvement (Bayesian Optimization)"}),"\n",(0,o.jsx)(i.p,{children:"Bayesian Optimization (BO) algorithms are machine learning-based algorithms that are particularly well suited to efficiently optimizing noisy objectives with few iterations. Using data collected during and/or prior to optimization, BO algorithms use Bayesian statistics to build a model of the objective function that predicts a distribution of possible function values at each point in parameter space. It then uses an acquisition function to make sampling decisions based on determining the global optimum of the objective function."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Global or local optimization depending on algorithm specifications"}),"\n",(0,o.jsx)(i.li,{children:"Creates an online surrogate model of the objective and any constraint functions, which can be used during or after optimization"}),"\n",(0,o.jsx)(i.li,{children:"Can account for observational constraints"}),"\n",(0,o.jsx)(i.li,{children:"Can incorporate rich prior information about the optimization problem to improve convergence"}),"\n",(0,o.jsx)(i.li,{children:"Explicitly handles measurement uncertainty and/or noisy objectives"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Potentially significant computational costs, especially after many iterations"}),"\n",(0,o.jsx)(i.li,{children:"Numerous hyperparameters which can affect performance"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"rcds",children:"RCDS"}),"\n",(0,o.jsx)(i.p,{children:"Robust Conjugate Direction Search makes decisions via successive local approximations of the objective function to converge to an optimum. RCDS may be more efficient than Nelder-Mead but requires multiple iterations initially to establish a local model of the objective function before starting to optimize."}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Advantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Low computational cost"}),"\n",(0,o.jsx)(i.li,{children:"Historically proven performance in the context of accelerator physics"}),"\n",(0,o.jsx)(i.li,{children:"Can account for measurement noise via algorithm hyperparameter"}),"\n",(0,o.jsx)(i.li,{children:"Can control scaling of step size"}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.strong,{children:"Disadvantages:"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Local optimizer, sensitive to initial starting conditions"}),"\n",(0,o.jsx)(i.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,o.jsx)(i.li,{children:"Cannot handle observational constraints"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>a});var t=n(6540);const o={},s=t.createContext(o);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);