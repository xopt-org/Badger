"use strict";(self.webpackChunkbadger_home=self.webpackChunkbadger_home||[]).push([[2751],{2073:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_bottom_buttons-f73276affbd4be9d4fcb29991c62ad90.png"},2522:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_history_navigator-1dac35438e4081da3ce190cc843fc83d.png"},3597:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_load_template-da89f1242ab25f1c94cb47e7f187582b.png"},4666:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_plot_area_run_data-4a6f83c986ab62761456c3ab2691a523.png"},5332:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_new_optimization_1-dd9153d8d7bedbb6a1d67a03c29b9f83.png"},5885:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_metadata-5153a761d43a0a5be5c76b784cb5fa2b.png"},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>r});var n=i(6540);const a={},o=n.createContext(a);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(o.Provider,{value:t},e.children)}},8791:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_algorithm-6fee89fd5bc3406f3eca9364982f7f61.png"},8895:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/highlight_new_optimization_2-d35154ff948347eb16bccba321f9cad9.png"},9813:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/gui-usage","title":"GUI Usage","description":"Once you launch Badger in GUI mode, you\'ll have various Badger features to explore. You can search through this page to get to the guide on any specify GUI feature, or if you believe a guide is missing for the topic you are interested in, please consider raising an issue here or shooting us an email, many thanks :)","source":"@site/versioned_docs/version-1.4/guides/gui-usage.md","sourceDirName":"guides","slug":"/guides/gui-usage","permalink":"/Badger/docs/guides/gui-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/SLAC-ML/Badger-Home/edit/master/versioned_docs/version-1.4/guides/gui-usage.md","tags":[],"version":"1.4","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Tutorial","permalink":"/Badger/docs/getting-started/tutorial_0"},"next":{"title":"History","permalink":"/Badger/docs/guides/history"}}');var a=i(4848),o=i(8453);const s={sidebar_position:1},r="GUI Usage",l={},d=[{value:"GUI Layout",id:"gui-layout",level:2},{value:"Environment + VOCS",id:"environment--vocs",level:3},{value:"Algorithm",id:"algorithm",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Loading a Template",id:"loading-a-template",level:3},{value:"History Navigator",id:"history-navigator",level:3},{value:"Plot Area and Run Data",id:"plot-area-and-run-data",level:3},{value:"To Define a New Optimization Routine",id:"to-define-a-new-optimization-routine",level:2},{value:"Running the Optimization",id:"running-the-optimization",level:2},{value:"Overview of Different Optimization Algorithms",id:"overview-of-different-optimization-algorithms",level:2},{value:"Nelder-Mead",id:"nelder-mead",level:3},{value:"Extremum Seeking",id:"extremum-seeking",level:3},{value:"Expected Improvement (Bayesian Optimization)",id:"expected-improvement-bayesian-optimization",level:3},{value:"RCDS",id:"rcds",level:3}];function h(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"gui-usage",children:"GUI Usage"})}),"\n",(0,a.jsxs)(t.p,{children:["Once you launch Badger in GUI mode, you'll have various Badger features to explore. You can search through this page to get to the guide on any specify GUI feature, or if you believe a guide is missing for the topic you are interested in, please consider ",(0,a.jsx)(t.a,{href:"https://github.com/xopt-org/Badger/issues/new",children:"raising an issue here"})," or ",(0,a.jsx)(t.a,{href:"mailto:zhezhang@slac.stanford.edu",children:"shooting us an email"}),", many thanks :)"]}),"\n",(0,a.jsx)(t.h2,{id:"gui-layout",children:"GUI Layout"}),"\n",(0,a.jsxs)(t.p,{children:["The Badger GUI is an interface made for optimizing accelerator performance. Behind the scenes, Badger uses Xopt, a python package designed to support a wide variety of control system optimization problems and algorithms. There are four important sections to defining an optimization problem using the Badger GUI: ",(0,a.jsx)(t.strong,{children:"Environment"}),", ",(0,a.jsx)(t.strong,{children:"VOCS"}),", ",(0,a.jsx)(t.strong,{children:"Algorithm"}),", and ",(0,a.jsx)(t.strong,{children:"Metadata"}),". The Badger GUI organizes these into three tabs, with Environment + VOCS being combined into a single main tab."]}),"\n",(0,a.jsx)(t.h3,{id:"environment--vocs",children:"Environment + VOCS"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"Environment"})," defines available variables and observables for a specific machine or control system. At SLAC, possible environments include ",(0,a.jsx)(t.code,{children:"LCLS"}),", ",(0,a.jsx)(t.code,{children:"FACET"}),", and ",(0,a.jsx)(t.code,{children:"LCLS_II"}),". Each environment contains information about the variables available within that system, such as their bounds, along with operational parameters for data collection such as number of points, trim delay, fault timeout, and other information related to the interaction between the optimizer and the physical or simulated environment."]}),"\n",(0,a.jsxs)(t.p,{children:["Within an environment, an optimization problem can be defined by selecting which variables to adjust, objectives to optimize, and any constraints to follow. ",(0,a.jsx)(t.strong,{children:"VOCS"})," represents the subset of variables, objectives, and constraints to be optimized within the environment. You can also add observables within the VOCS section, which the GUI will monitor and display but won\u2019t otherwise interact with. The \u201cConstraints\u201d and \u201cObservables\u201d sections are optional for defining an optimization and are collapsed by default. They can be accessed by clicking on ",(0,a.jsx)(t.strong,{children:"More"})," at the bottom of the Environment + VOCS tab."]}),"\n",(0,a.jsx)(t.h3,{id:"algorithm",children:"Algorithm"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI algorithm panel",src:i(8791).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.strong,{children:"Algorithm"})," section lets you select an algorithm to use for optimization (1), as well as set the parameters of the selected algorithm (2). See \u201c",(0,a.jsx)(t.em,{children:"Overview of Different Optimization Algorithms"}),"\u201d for a more detailed overview of different options. Common algorithms used at SLAC are expected improvement and nelder-mead."]}),"\n",(0,a.jsx)(t.h3,{id:"metadata",children:"Metadata"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI metadata panel",src:i(5885).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Metadata"})," includes a name (1) and description (2) for the optimization routine. Beneath the description there is also a button to save the current run configuration as a template."]}),"\n",(0,a.jsx)(t.h3,{id:"loading-a-template",children:"Loading a Template"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI load template button",src:i(3597).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.p,{children:["If there is already a template for the optimization you\u2019d like to run, click the ",(0,a.jsx)(t.strong,{children:"Load Template"})," button at the upper left of the ",(0,a.jsx)(t.strong,{children:"Environment + VOCS"})," tab, and select the appropriate template. Make sure to check the environment parameters, variables and variable ranges, objectives, constraints/observables, and selected algorithm before running the optimization. See ",(0,a.jsx)(t.a,{href:"templates",children:"the templates page"})," for more information about templates."]}),"\n",(0,a.jsx)(t.h3,{id:"history-navigator",children:"History Navigator"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI history navigator panel",src:i(2522).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsx)(t.p,{children:"The History Navigator holds past runs, whose output can be loaded again with a single click on a given yaml file entry. Past runs are hierarchically organized by year, year and month, and year, month, and day, just like how they are organized in the Badger archive directory."}),"\n",(0,a.jsx)(t.h3,{id:"plot-area-and-run-data",children:"Plot Area and Run Data"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI plot area and run data panel",src:i(4666).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Plot Area"})," is where run data is visualized as a line graph."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Run Data"})," holds the raw data points which are fed into the plot."]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"to-define-a-new-optimization-routine",children:"To Define a New Optimization Routine"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI new optimization, upper page",src:i(5332).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Start by selecting the target environment"})," from the ",(0,a.jsx)(t.strong,{children:"Environment"})," dropdown. Click the ",(0,a.jsx)(t.strong,{children:"Parameters"})," button to expand the available environment parameters."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"From the \u201cVariables\u201d table select devices to be optimized."}),(0,a.jsx)(t.br,{}),"\n","The variables table shows all the variables which have been included in the selected environment. You can also toggle the ",(0,a.jsx)(t.strong,{children:"Show Checked Only"})," checkbox to only display selected variables. If a device you\u2019d like to try to optimize is not listed, you can scroll to the bottom of the table and enter a new PV. The ",(0,a.jsx)(t.strong,{children:"Min"})," and ",(0,a.jsx)(t.strong,{children:"Max"})," columns in the table show the bounds of the search space for optimization. If the ",(0,a.jsx)(t.strong,{children:"Automatic"})," checkbox above the table is checked, these bounds will be \xb1 some percentage from the current value. Clicking ",(0,a.jsx)(t.strong,{children:"Set Variable Range"})," will open a dialog window showing that ratio, and an option to select either relative to current or relative to the full variable range. Unchecking ",(0,a.jsx)(t.strong,{children:"Automatic"})," allows you to manually set variable ranges by editing the values in the ",(0,a.jsx)(t.strong,{children:"Min"})," and ",(0,a.jsx)(t.strong,{children:"Max"})," columns."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"If the \u201cAutomatic\u201d checkbox is checked, selecting a variable will automatically add a set of initial points."}),(0,a.jsx)(t.br,{}),"\n","By default, these will be the current value followed by three random points within a fraction of the variable bounds centered around the current value. If ",(0,a.jsx)(t.strong,{children:"Automatic"})," is not checked, or to adjust the initial points, you can use the ",(0,a.jsx)(t.strong,{children:"Add Current"})," and ",(0,a.jsx)(t.strong,{children:"Add Random"})," buttons to configure your own initial points."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI new optimization, lower page",src:i(8895).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Select an objective from the \u201cObjectives\u201d table."}),(0,a.jsx)(t.br,{}),"\n","Make sure to select whether the objective should be maximized or minimized! Currently only single objective optimization is available, but multi-objective optimization will be supported in the future."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Add constraints and observables."}),(0,a.jsx)(t.br,{}),"\n","Beneath the ",(0,a.jsx)(t.strong,{children:"Objectives"})," table is a collapsable ",(0,a.jsx)(t.strong,{children:"More"})," section, which allows you to add Constraints and Observables. The constraints and observables available for selection are based on the selected environment."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Choose an optimization algorithm."}),(0,a.jsx)(t.br,{}),"\n","There are several different optimization algorithms available within the Badger GUI. Generally, ",(0,a.jsx)(t.strong,{children:"expected improvement"})," and ",(0,a.jsx)(t.strong,{children:"Nelder-Mead"}),' are good choices for online accelerator optimization. To select an algorithm navigate to the "Algorithm" tab. To read more about different algorithms, see the "',(0,a.jsx)(t.a,{href:"#overview-of-different-optimization-algorithms",children:"Overview of Different Optimization Algorithms"}),"\u201d section below."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Metadata:"}),(0,a.jsx)(t.br,{}),"\n","Provide a name and description for your optimization routine."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"running-the-optimization",children:"Running the Optimization"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Badger GUI action buttons",src:i(2073).A+"",width:"1852",height:"1119"})}),"\n",(0,a.jsxs)(t.p,{children:["Once the environment, variables, objectives, and algorithm (and any optional constraints and observables) have been defined, the optimization can be started by pressing the green ",(0,a.jsx)(t.strong,{children:"run"})," button (5) at the lower center of the GUI. Badger will begin by measuring the objective at the initial points specified in the ",(0,a.jsx)(t.strong,{children:"Initial Points"})," table, and will then begin to optimize the selected variables using the chosen algorithm. When the scan is active, the green ",(0,a.jsx)(t.strong,{children:"run"})," button will turn into a red ",(0,a.jsx)(t.strong,{children:"stop"})," button."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Once the scan has started, it can be paused/resumed using the ",(0,a.jsx)(t.strong,{children:"play/pause"})," button (4) to the left of the ",(0,a.jsx)(t.strong,{children:"run"})," button."]}),"\n",(0,a.jsxs)(t.li,{children:["To end the optimization run, press the red ",(0,a.jsx)(t.strong,{children:"stop"})," button (5)."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["After ending the optimization, you may want to take some sort of action on the variables/devices being optimized. Depending on the algorithm selected, the last point/state sampled may not be the best that was found during the optimization run. To select the best configuration of variables that was measured, press the star button titled ",(0,a.jsx)(t.strong,{children:"Jump to Optimal"})," (6) to the right of the stop/start button. Alternatively, clicking any point in the optimization plot will highlight the variable values at that point in the scan. Once you\u2019ve chosen the solution you\u2019d like to implement, press ",(0,a.jsx)(t.strong,{children:"Dial in solution"})," (7) to set devices to the selected values."]}),"\n",(0,a.jsxs)(t.p,{children:["To reset all the variables to their values at the beginning of the scan, press the ",(0,a.jsx)(t.strong,{children:"Reset Environment"})," button (3)."]}),"\n",(0,a.jsx)(t.p,{children:"Pressing the extensions button (8) will allow opening extension windows such as BOVisualizer and ParetoFrontViewer."}),"\n",(0,a.jsx)(t.p,{children:"Pressing the delete button (1) will delete the stored run data from the History Navigator panel and on disk. Pressing the log button (2) will save the current run's log to the configured logbook directory."}),"\n",(0,a.jsx)(t.p,{children:"While the optimization is running, the values of the variables, objectives, and (if selected) constraints and observables will be plotted in the plot section in the top right corner of the GUI. By default, the X-Axis displays the number of optimization iterations, and the Y-Axis for the variables plot is relative to each variable\u2019s starting value. These options can be changed from the GUI via options in the top right corner, above the plots."}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"overview-of-different-optimization-algorithms",children:"Overview of Different Optimization Algorithms"}),"\n",(0,a.jsx)(t.h3,{id:"nelder-mead",children:"Nelder-Mead"}),"\n",(0,a.jsx)(t.p,{children:"Iterative downhill simplex algorithm which seeks to find local optima by sampling initial points and then using a heuristic to choose the next point during each iteration. Nelder-Mead has been widely used inside accelerator physics."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Low computational cost"}),"\n",(0,a.jsx)(t.li,{children:"Historically proven performance in the context of accelerator physics"}),"\n",(0,a.jsx)(t.li,{children:"Automatic/adaptive hyperparameter specification depending on problem characteristics"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Disadvantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Local optimizer \u2013 sensitive to initial starting conditions"}),"\n",(0,a.jsx)(t.li,{children:"Sensitive to measurement noise which can negatively impact convergence to optimum"}),"\n",(0,a.jsx)(t.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,a.jsx)(t.li,{children:"Cannot handle observational constraints"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"extremum-seeking",children:"Extremum Seeking"}),"\n",(0,a.jsx)(t.p,{children:"Perform small oscillations to measurement to slowly move towards minimum. This algorithm uses a sinusoidal sampling strategy for each parameter to slowly drift towards optimal operating conditions and track time dependent changes in the optimal operating conditions over time. It\u2019s useful for time dependent optimization, where short term drifts in accelerator conditions can lead to a time dependent objective function."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Low computational cost"}),"\n",(0,a.jsx)(t.li,{children:"Can track time-dependent drifts of the objective function to maintain an optimal operating configuration"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Disadvantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Local optimizer, sensitive to initial starting conditions"}),"\n",(0,a.jsx)(t.li,{children:"Additional hyperparameters that must be tuned to a given optimization problem"}),"\n",(0,a.jsx)(t.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,a.jsx)(t.li,{children:"Cannot handle observational constraints"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"expected-improvement-bayesian-optimization",children:"Expected Improvement (Bayesian Optimization)"}),"\n",(0,a.jsx)(t.p,{children:"Bayesian Optimization (BO) algorithms are machine learning-based algorithms that are particularly well suited to efficiently optimizing noisy objectives with few iterations. Using data collected during and/or prior to optimization, BO algorithms use Bayesian statistics to build a model of the objective function that predicts a distribution of possible function values at each point in parameter space. It then uses an acquisition function to make sampling decisions based on determining the global optimum of the objective function."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Global or local optimization depending on algorithm specifications"}),"\n",(0,a.jsx)(t.li,{children:"Creates an online surrogate model of the objective and any constraint functions, which can be used during or after optimization"}),"\n",(0,a.jsx)(t.li,{children:"Can account for observational constraints"}),"\n",(0,a.jsx)(t.li,{children:"Can incorporate rich prior information about the optimization problem to improve convergence"}),"\n",(0,a.jsx)(t.li,{children:"Explicitly handles measurement uncertainty and/or noisy objectives"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Disadvantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Potentially significant computational costs, especially after many iterations"}),"\n",(0,a.jsx)(t.li,{children:"Numerous hyperparameters which can affect performance"}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"rcds",children:"RCDS"}),"\n",(0,a.jsx)(t.p,{children:"Robust Conjugate Direction Search makes decisions via successive local approximations of the objective function to converge to an optimum. RCDS may be more efficient than Nelder-Mead but requires multiple iterations initially to establish a local model of the objective function before starting to optimize."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Advantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Low computational cost"}),"\n",(0,a.jsx)(t.li,{children:"Historically proven performance in the context of accelerator physics"}),"\n",(0,a.jsx)(t.li,{children:"Can account for measurement noise via algorithm hyperparameter"}),"\n",(0,a.jsx)(t.li,{children:"Can control scaling of step size"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Disadvantages:"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Local optimizer, sensitive to initial starting conditions"}),"\n",(0,a.jsx)(t.li,{children:"Scales poorly to higher dimensional problems"}),"\n",(0,a.jsx)(t.li,{children:"Cannot handle observational constraints"}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);