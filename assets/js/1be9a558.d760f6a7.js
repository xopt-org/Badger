"use strict";(self.webpackChunkbadger_home=self.webpackChunkbadger_home||[]).push([[4729],{976:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"guides/templates","title":"Templates","description":"Loading a Template","source":"@site/docs/guides/templates.md","sourceDirName":"guides","slug":"/guides/templates","permalink":"/Badger/docs/next/guides/templates","draft":false,"unlisted":false,"editUrl":"https://github.com/SLAC-ML/Badger-Home/edit/master/docs/guides/templates.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"History","permalink":"/Badger/docs/next/guides/history"},"next":{"title":"Optimization Algorithms Overview","permalink":"/Badger/docs/next/guides/algorithms-overview"}}');var i=n(4848),r=n(8453);const o={sidebar_position:3},s="Templates",l={},d=[{value:"Loading a Template",id:"loading-a-template",level:2},{value:"Defining Template Files",id:"defining-template-files",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"templates",children:"Templates"})}),"\n",(0,i.jsx)(t.h2,{id:"loading-a-template",children:"Loading a Template"}),"\n",(0,i.jsxs)(t.p,{children:["If there is already a template for the optimization you\u2019d like to run, click the ",(0,i.jsx)(t.strong,{children:"Load Template"})," button at the upper left of the ",(0,i.jsx)(t.strong,{children:"Environment + VOCS"})," tab, and select the appropriate template. Make sure to check the environment parameters, variables and variable ranges, objectives, constraints/observables, and selected algorithm before running the optimization."]}),"\n",(0,i.jsx)(t.h2,{id:"defining-template-files",children:"Defining Template Files"}),"\n",(0,i.jsxs)(t.p,{children:["To save the current scan parameters as a template from the GUI, navigate to the ",(0,i.jsx)(t.strong,{children:"Metadata"})," tab. Click ",(0,i.jsx)(t.strong,{children:"Save as Template"}),", and enter an appropriate filename ending in \u201c.yaml\u201d. This will save the Environment, VOCS, Algorithm, and Metadata currently displayed on the GUI to a YAML file, including environment and algorithm parameters and relative variable ranges, and the configuration of initial points."]}),"\n",(0,i.jsx)(t.p,{children:"Templates can also be directly saved or edited as YAML files, with the following format:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:"name: ''            # name of template\ndescription: ''     # description of template\nenvironment:\n  name: ''          # environment name\n  params: {}        # environment parameters, depend on environment\ngenerator:\n  name:             # generator name\n  # params will depend on generator\nvocs:               # XOPT VOCS\n  constants: {}     # {constant_name: value}\n  constraints: {}   # {constraint_name: [GREATER_THAN or LESS_THAN, value]}\n  objectives: {}    # {objective_name: MINIMIZE or MAXIMIZE}\n  observables: []   # list of observable names\n  variables: {}     # {variable_name: [lower_bound, upper_bound]}\n                    \n                    # Note that the variable upper and lower bound should be\n                    # the absolute variable range limits, not the limit of the \n                    # optimization. The range of the optimization is set based \n                    # on vrange_limit_options for each variable, either as a \n                    # fraction of the full range or \xb1 a fraction of the\n                    # current value.\n\nvrange_limit_options: {} \n\n                    # for each variable:\n                    #   variable: {limit_option_idx: 0 or 1, ratio_curr: 0.1, ratio_full: 0.1}\n                    # For example:\n                    #   QUAD:LTUH:620:BCTRL:\n                    #   limit_option_idx: 0\n                    #   ratio_curr: 0.1 \n                    #   ratio_full: 0.1\n                    # Note that ratio_curr is the ratio with respect to the current value\n                    # and ratio_full is the ratio with respect to the full variable range.\n                    # limit_option_idx 0 will use ratio_curr, 1 is ratio_full\n\nrelative_to_current: true  # true or false.\ninitial_point_actions: [{}]  # list of dictionaries\n\n                    # Will be read sequentially.\n                    # For example, the two most common options would look like:\n                    #\n                    # - type: add_curr     # will add the current value of selected vars\n                    # - config: \n                    #     fraction: 0.1\n                    #     method: 0\n                    #     n_points: 3\n                    #   type: add_rand\n                    #\n                    # will add three random points for each variable, selected\n                    # from within 0.1*(the vrange limit ratio for that \n                    # variable) around the current value \u2013 i.e. sample n random \n                    # points from within a subset of the scan range\n\ncritical_constraint_names: []  # list of constraints (from VOCS) to be marked as \u2018critical\u2019\nbadger_version:     # optional but helpful\nxopt_version:       # optional but helpful\n"})})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(6540);const i={},r=a.createContext(i);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);